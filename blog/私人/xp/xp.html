---
layout: chengjiu
title: XP
nav_url: <a href="/maoqiu">关于</a>
permalink: xp
---
<script>
// "hr／标题",
// "111／标题／小字／提示",
// ／u／https://xx",
// ／o／dw(dwb='111',dwd='标题')",

//喜好：1还行 2提起兴趣 3想要得到 4计划得到 5必须得到
//邪念：1还行 2心里痒痒 3会有反应 4反应强烈 5难以平复
//1个满分或4+4★ 5+4★★ 双满分★★★
let cj_data={
"普通XP":[
"/i/cj/xp/55／虎牙／／喜好：★★★★<br>邪念：★★",
"/i/cj/xp/54／后背／／喜好：★★★<br>邪念：★★",

"hr／属性",
"/i/cj/xp/48／兄 x 妹／独生子女的执念／喜好：★★★<br>邪念：★",
"/i/cj/xp/37／姐 x 弟／／喜好：★★★<br>邪念：★★",
"/i/cj/xp/59／少女／／喜好：★★★<br>邪念：★★",
"/i/cj/xp/32／御姐／／喜好：★★★<br>邪念：★★",
"/i/cj/xp/49／御姐 x 正太／／喜好：★★★<br>邪念：★★",
"/i/cj/xp/1／贫乳 ★／／喜好：★★★★★<br>邪念：★★★",
"/i/cj/xp/58／轻度福瑞／／喜好：★<br>邪念：★",

"hr／亲密接触",
"/i/cj/xp/56／摸脸 ★／／喜好：★★★★★<br>邪念：★★★",
"/i/cj/xp/61／脸贴脸／／喜好：★★★★<br>邪念：★★★★",
"/i/cj/xp/57／摸头／／喜好：★★★<br>邪念：★★",
"/i/cj/xp/65／坐在怀里／／喜好：★★<br>邪念：★★",
"/i/cj/xp/5／倒吻／／喜好：★★<br>邪念：★★★",
"/i/cj/xp/30／一起泡澡／／喜好：★★★<br>邪念：★★★",
"/i/cj/xp/39／口交 ★★★／／喜好：★★★★★<br>邪念：★★★★★",
"/i/cj/xp/38／抠 ★★★／／喜好：★★★★★<br>邪念：★★★★★",
"/i/cj/xp/44／舔 ★／／喜好：★★★★<br>邪念：★★★★",
"/i/cj/xp/16／女上阴部摩擦／／喜好：★★★<br>邪念：★★★★",
"/i/cj/xp/34／69式 ★★★／／喜好：★★★★★<br>邪念：★★★★★",

"hr／性别",
"/i/cj/xp/18／女性强势 ★／／喜好：★★★★<br>邪念：★★★★",
"/i/cj/xp/15／男娘／／喜好：★★★<br>邪念：★★★★",
"/i/cj/xp/14／男娘 x 女／／喜好：★★★<br>邪念：★★★",
"/i/cj/xp/4／百合控 ★／／喜好：★★★★<br>邪念：★★★★",
"/i/cj/xp/2／lex x boy ★★／／喜好：★★★★<br>邪念：★★★★★",
"/i/cj/xp/28／伪男半裸／／喜好：★★★<br>邪念：★★★",

"hr／轻度露出",
"/i/cj/xp/10／露出 ★★／／喜好：★★★★★<br>邪念：★★★★",
"/i/cj/xp/13／裸体自拍／／喜好：★★★★<br>邪念：★★★",
"/i/cj/xp/33／走光／／喜好：★★★★<br>邪念：★★",
"/i/cj/xp/45／提起裙子／／喜好：★★★<br>邪念：★★",
"/i/cj/xp/50／真空／／喜好：★★★<br>邪念：★★★",
"/i/cj/xp/31／意外的裸露行为／／喜好：★★★<br>邪念：★★",

"hr／中度露出",
"/i/cj/xp/24／生活感、无防备 ★／／喜好：★★★★<br>邪念：★★★★",
"/i/cj/xp/12／裸体模特／／喜好：★★★★<br>邪念：★★★",
"/i/cj/xp/27／脱衣游戏 ★／／喜好：★★★★<br>邪念：★★★★",
"/i/cj/xp/43／全裸合照／／喜好：★★★★<br>邪念：★★★",
"/i/cj/xp/51／桌下口交／／喜好：★★★★<br>邪念：★★★",
"/i/cj/xp/26／偷偷自慰 ★／／喜好：★★★★<br>邪念：★★★★",
"/i/cj/xp/25／偷偷性爱 ★★／／喜好：★★★★<br>邪念：★★★★★",
"/i/cj/xp/22／全裸外出 ★★／／喜好：★★★★★<br>邪念：★★★★",
"/i/cj/xp/35／CFNM（男裸） ★★★／／喜好：★★★★★<br>邪念：★★★★★",
"/i/cj/xp/36／CMNF（女裸）／／喜好：★★★★<br>邪念：★★★",

"hr／重度露出",
"/i/cj/xp/21／强制露出／／喜好：★★★<br>邪念：★★★",
"/i/cj/xp/7／公开性爱／／喜好：★★★<br>邪念：★★★★",

"hr／逆寝取",
"/i/cj/xp/29／一男多女 ★★★／／喜好：★★★★★<br>邪念：★★★★★",
"/i/cj/xp/19／女性助攻 ★★★／／喜好：★★★★★<br>邪念：★★★★★",
"/i/cj/xp/40／逆NTR ★★★／／喜好：★★★★★<br>邪念：★★★★★",

"hr／轻度SM",
"/i/cj/xp/8／口内指責／／喜好：★★★<br>邪念：★★★",
"/i/cj/xp/41／掐脖子／／喜好：★★★<br>邪念：★★★",
"/i/cj/xp/46／项圈／／喜好：★★★<br>邪念：★★",

"hr／？／我也不知道为啥……",
"/i/cj/xp/52／被告白／／喜好：★★<br>邪念：★★★",
"/i/cj/xp/53／分手／／喜好：★★<br>邪念：★★★",
"/i/cj/xp/9／哭泣／／喜好：★★<br>邪念：★★★",
"/i/cj/xp/63／无邪念的同床睡觉／一个神奇的悖论／喜好：★★★<br>邪念：★★★<br>“无邪念”这点会比普通“同床睡觉”更让我起邪念，但既然起邪念了这就不是“无邪念”的了……",

"hr／其他",
"/i/cj/xp/20／女性自慰 ★／／喜好：★★★★<br>邪念：★★★★",
"/i/cj/xp/64／性瘾／／喜好：★★★<br>邪念：★★★★",
"/i/cj/xp/60／事后／／喜好：★★<br>邪念：★★",
"/i/cj/xp/47／性器观察 ★／／喜好：★★★★<br>邪念：★★★★",
"/i/cj/xp/6／非色情的裸露 ★／／喜好：★★★★<br>邪念：★★★★",
"/i/cj/xp/62／无套／／喜好：★★★<br>邪念：★★★",


// "/i/cj/xp/66／／／喜好：<br>邪念：",
// "/i/cj/xp/／／／喜好：<br>邪念：",

],
"血腥、暴力、猎奇":[
"hr／暴力",
"/i/cj/xp/3／霸凌／／喜好：★★<br>邪念：★★★<br>现实中不喜欢霸凌",
"/i/cj/xp/17／女性霸凌／／喜好：★★★<br>邪念：★★★",

"hr／血腥",
"/i/cj/xp/42／轻度割伤／／喜好：★<br>邪念：★★★<br>我不喜欢受伤和伤口，还有点晕血来着，但不知道为什么会对这个有反应……",

"hr／淫乱",
"/i/cj/xp/11／乱交、淫乱感／／喜好：★★★<br>邪念：★★★★",

"hr／猎奇",
"/i/cj/xp/23／人棍／／喜好：★★<br>邪念：★★",

]
};

(function () {
    const processBlockOrder = [8,6,2,0,4,7,1,3,5];
    const restoreBlockOrder = new Array(9);
    processBlockOrder.forEach((sourceIdx, targetIdx) => {
        restoreBlockOrder[sourceIdx] = targetIdx;
    });

    const dyContainer = document.getElementById('dy');

    const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
            mutation.addedNodes.forEach((node) => {
                if (node.tagName === 'IMG') {
                    restoreImage(node);
                } else {
                    const imgElements = node.querySelectorAll('img');
                    imgElements.forEach((img) => {
                        restoreImage(img);
                    });
                }
            });
        });
    });

    observer.observe(dyContainer, {
        childList: true,
        subtree: true
    });

    /**
     * 还原单张图片
     * @param {HTMLImageElement} img - 需要还原的图片元素
     */
    function restoreImage(img) {
        if (img.dataset.restored === 'true') return;

        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const tempImage = new Image();
        tempImage.crossOrigin = 'anonymous';

        tempImage.onload = function () {
            canvas.width = tempImage.width;
            canvas.height = tempImage.height;

            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(tempImage, 0, 0);
            let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

            imageData = rearrangeBlocks(imageData, canvas.width, canvas.height, restoreBlockOrder);
            imageData = flipVertical(imageData, canvas.width, canvas.height);
            imageData = invertColor(imageData);
            ctx.putImageData(imageData, 0, 0);
            img.src = canvas.toDataURL('image/jpeg', 1.0);
            img.dataset.restored = 'true';
        };

        tempImage.src = img.src;
    }

    // ---------------------- 与处理页面对应的反向处理函数 ----------------------
    /**
     * 图片反色（再次调用即可还原）
     * @param {ImageData} imageData - 图片像素数据
     * @returns {ImageData} 反色后的图片数据
     */
    function invertColor(imageData) {
        const data = imageData.data;
        for (let i = 0; i < data.length; i += 4) {
            data[i] = 255 - data[i];
            data[i + 1] = 255 - data[i + 1];
            data[i + 2] = 255 - data[i + 2];
        }
        return imageData;
    }

    /**
     * 图片上下翻转（再次调用即可还原）
     * @param {ImageData} imageData - 图片像素数据
     * @param {number} width - 图片宽度
     * @param {number} height - 图片高度
     * @returns {ImageData} 上下翻转后的图片数据
     */
    function flipVertical(imageData, width, height) {
        const newData = new Uint8ClampedArray(imageData.data.length);
        const data = imageData.data;

        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const originalIndex = (y * width + x) * 4;
                const newIndex = ((height - 1 - y) * width + x) * 4;
                newData[newIndex] = data[originalIndex];
                newData[newIndex + 1] = data[originalIndex + 1];
                newData[newIndex + 2] = data[originalIndex + 2];
                newData[newIndex + 3] = data[originalIndex + 3];
            }
        }
        return new ImageData(newData, width, height);
    }

    /**
     * 3x3分块还原（按反向顺序换位）
     * @param {ImageData} imageData - 图片像素数据
     * @param {number} width - 图片宽度
     * @param {number} height - 图片高度
     * @param {array} order - 还原的分块顺序
     * @returns {ImageData} 还原后的图片数据
     */
    function rearrangeBlocks(imageData, width, height, order) {
        const blockWidth = Math.floor(width / 3);
        const blockHeight = Math.floor(height / 3);
        const newData = new Uint8ClampedArray(imageData.data.length);
        const data = imageData.data;

        for (let targetIdx = 0; targetIdx < 9; targetIdx++) {
            const sourceIdx = order[targetIdx];
            const [sourceX, sourceY] = getBlockPosition(sourceIdx, blockWidth, blockHeight);
            const [targetX, targetY] = getBlockPosition(targetIdx, blockWidth, blockHeight);

            for (let y = 0; y < blockHeight; y++) {
                for (let x = 0; x < blockWidth; x++) {
                    const sourcePixelIndex = ((sourceY + y) * width + (sourceX + x)) * 4;
                    const targetPixelIndex = ((targetY + y) * width + (targetX + x)) * 4;

                    if (sourcePixelIndex < data.length && targetPixelIndex < newData.length) {
                        newData[targetPixelIndex] = data[sourcePixelIndex];
                        newData[targetPixelIndex + 1] = data[sourcePixelIndex + 1];
                        newData[targetPixelIndex + 2] = data[sourcePixelIndex + 2];
                        newData[targetPixelIndex + 3] = data[sourcePixelIndex + 3];
                    }
                }
            }
        }

        return new ImageData(newData, width, height);
    }

    /**
     * 根据块索引获取块的起始坐标
     * @param {number} index - 块索引（0-8）
     * @param {number} blockWidth - 每个块的宽度
     * @param {number} blockHeight - 每个块的高度
     * @returns {array} [x, y] 起始坐标
     */
    function getBlockPosition(index, blockWidth, blockHeight) {
        const row = Math.floor(index / 3);
        const col = index % 3;
        return [col * blockWidth, row * blockHeight];
    }
})();
</script>
<div id="yzdy"></div>
<script src="https://猫.cafe/biji/0/mq-手动确认.js"></script>